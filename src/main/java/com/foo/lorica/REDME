
This is a code testing for Lorica. This happened in 2018.
The following is a small coding exercise to help us understand how you write software. Have a good look at the problem before getting started. There are a few constraints, however they are mainly designed to help us evaluate how you did. You can use any language/environment to write your solution (maybe nothing too extreme like assembler or Prolog: we need to be able to understand it and we mainly use Java and javascript): The Task You have been asked to build a command line tool to calculate the number of full days elapsed in between the start and end dates of an event. The first and the last day are considered partial days and never counted. Following this logic, an event that has run from 07/11/1972 and 08/11/1972 should return 0, because there are no fully elapsed days contained in between those dates, and 01/01/2000 to 03/01/2000 should return 1. The solution needs to cater for all valid dates between 01/01/1901 and 31/12/2999.

Your output Send us your code, instructions on building and running it plus any other files that make up your solution or prove that it works. Test cases Some sample test data (DD/MM/YYYY): Input (DD/MM/YYYY)	Output (Days) 02/06/1983 22/06/1983	19 04/07/1984 25/12/1984	173 03/01/1989 03/08/1983	1979

Constraints

The solution should accept input and be testable from the command line.
Framework classes or libraries should NOT be used to solve the problem (i.e. don’t use a date/time class as that makes this exercise trivial) although it’s fine to use them for testing purposes.
We ask that you work on the solution by yourself and submit only your own code.
Hints

Less code is more, create a concise but complete solution.
It shouldn’t take more than a few hours. If it looks like it’s going to take significantly longer, it may be a good time to reconsider your approach.
We do want you to succeed, so help us understand why you made the design or programming choices you made.
This might make a great talking point at your face to face interview: be prepared to talk about what you did and why.
Last but not least: there is no perfect implementation, so don’t try to build one.